#!/usr/bin/env python

import roslib
import rospy
import actionlib
import math
import actionlib
import numpy as np
import random
import trajectory_msgs.msg as tm
from std_msgs.msg import String, Float32, Int16
from control_msgs.msg import JointTrajectoryControllerState, FollowJointTrajectoryAction, FollowJointTrajectoryGoal, FollowJointTrajectoryFeedback
from enum import Enum
from std_srvs.srv import Empty, EmptyResponse

STOP = 0
FORWARD = 1
BACKWARD = 2


class Swing:
    def __init__(self):
        self.dis_sub = rospy.Subscriber("goal_distance", Float32, self.distance_callback)

        self.joint_pub = rospy.Publisher('arm_controller/command', tm.JointTrajectory, queue_size=10)
        self.command_pub = rospy.Publisher('move_command', Int16, queue_size=10)

        self.arm_client = actionlib.SimpleActionClient('arm_controller/follow_joint_trajectory', FollowJointTrajectoryAction)
        self.arm_client.wait_for_server()
        rospy.sleep(1)




        self.joint_names = rospy.get_param("arm_controller/joints")
        print(self.joint_names)

        self.ready_srv = rospy.Service("ready", Empty, self.ready_callback)
        self.up_srv = rospy.Service("hit", Empty, self.hit_callback)

        self.goal_pos = np.zeros(len(self.joint_names))
        self.joint_vel = np.zeros(len(self.joint_names))
        self.duration = 1.5
        self.moving_base_direction = [STOP, STOP]
        self.swinging = True

        self.curr_dis = 0.0

    def distance_callback(self, data):
        rospy.loginfo("get distance: %s", data)
        self.curr_dis = data.data/1000.0



    def ready_callback(self, emp):
        self.moving_base_direction = [STOP, STOP, STOP]
        self.goal_pos = [[0.0, -1.0, 0.0, -1.87, 0.0, 3.14], [0.0, -1.0, 0.0, -1.87, -1.57, 3.14], [0.0, -1.0, 1.3, -1.87, -1.57, 3.14]]
        print("ready")

        self.swinging = False

        


        return EmptyResponse()

    def hit_callback(self, emp):
        self.moving_base_direction = [BACKWARD, FORWARD]
        self.goal_pos = [[-1.8, -1.0, 1.3, -1.87, -3.0, 3.14], [1.8, -1.0, 1.3, -1.87, -0.14, 3.14]]
        print("hit")
        # v = math.sqrt(9.8*self.curr_dis/math.sin(2*0.566))

        # v_club = (0.04593*v)/10
        # omega = v_club/(0.39225+0.425)
        # self.duration = 1.0*(3.6/omega)

        self.duration = 1.0#(self.curr_dis - 16.954)/(-12.436)

        rospy.loginfo("hitting duration: %s", str(self.duration))
        # self.duration = 0.7

        self.swinging = False
        return EmptyResponse()

    def move_to_pose(self):
        self.swinging = True
        for i in range(len(self.goal_pos)):
            self.command_pub.publish(Int16(self.moving_base_direction[i]))
            

            arm_traj = tm.JointTrajectory()
            arm_traj.joint_names = self.joint_names

            jtp = tm.JointTrajectoryPoint()
            jtp.positions = self.goal_pos[i]
            jtp.velocities = self.joint_vel
            jtp.accelerations = np.zeros(len(self.joint_names))
            jtp.time_from_start = rospy.Duration(self.duration)
            arm_traj.points.append(jtp)

            arm_goal = FollowJointTrajectoryGoal()


            arm_goal.trajectory = arm_traj
            arm_goal.goal_time_tolerance = rospy.Duration(0)

            self.arm_client.send_goal(arm_goal)
            res = self.arm_client.wait_for_result()
            if res:
                print('success')
            else:
                print('fail')


            self.command_pub.publish(Int16(0))


            rospy.sleep(0.5)

        




def main():
    """ The main() function. """
    #ros node init

    rospy.init_node('swing')
    r = rospy.Rate(10)

    swing = Swing()

    while not rospy.is_shutdown():
        if not swing.swinging:
            swing.move_to_pose()
        r.sleep()



if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
